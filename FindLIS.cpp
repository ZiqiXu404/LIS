/*
 * FindLIS.cpp
 *
 * CS 160 Class Project
 * by Ziqi Xu, 11/21/2021
 * 
 * Find the longest increasing subsequence of the input array using
 * two different algorithms and calculate the runtime.
 *
 */

#include <iostream>
#include <fstream>
#include <vector>
#include <stack>
#include <exception>
#include <limits>
#include <chrono>

#include "FindLIS.h"

using namespace std::chrono;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: nullary constructor
 * @purpose: initialize a FindLIS instance
 * @parameters: none
 * @return: none
 */
FindLIS::FindLIS()
{
    array_size = 0;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: nullary destructor
 * @purpose: deallocate all memory associated with the FindLIS instance
 * @parameters: none
 * @return: none
 */
FindLIS::~FindLIS()
{
    
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: run
 * @purpose: start the program and use the input from std::cin 
 * @parameters: none
 * @return: none
 */
void FindLIS::run()
{
    run("");
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: run overload
 * @purpose: start the program and determine which input stream to use
 * @parameters: a string of the filename 
 * @return: none
 */
void FindLIS::run(std::string filename)
{
    // take the input and store the array
    if (filename == "") 
        take_usr_input();
    else 
        take_file_input(filename);
    
    // If the input is empty
    if (array_size == 0) {
        std::cout << "The input array is empty and there is no LIS." 
                  << std::endl;
        return;
    }

    // output the input array info
    print_array("input_array", input_array);
    
    // using the 1st DP algorithm to find the LIS and measure its runtime
    find_lis_dp();  

    // using the 2nd optimal algorithm to find the LIS and measure its runtime
    find_lis_optimal();
    
    // diff LIS size
    diff_lis_size();

    // diff runtime
    diff_runtime();
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: diff_lis_size
 * @purpose: Compare the lengths of the two LIS's generated by two different
 *           methods.
 * @parameters: none
 * @return: none
 */
void FindLIS::diff_lis_size()
{
    if (dp_lis.size() == opt_lis.size()) {
        std::cout << "The two methods produce the same legnth of LIS!"
                  << " They both work!" << std::endl;
        std::cout << "The length of the LIS is: " 
                  << dp_lis.size() << std::endl;
    }
    else {
        std::cout << "Oops. There is some error in the algorithms, because "
                  << "they generate different sizes of LIS from the same input"
                  << std::endl;
    }
    std::cout << std::endl;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: diff_runtime
 * @purpose: Compare the runtime of two algorithms over the same input
 * @parameters: none
 * @return: none
 */
void FindLIS::diff_runtime()
{
    // print the runtimes of the two algorithms 
    std::cout << "The runtime of using the convential DP algorithm is: "
              << dp_duration.count() << " microseconds." << std::endl;
    
    std::cout << "The runtime of using the optimal algorithm is: "
              << opt_duration.count() << " microseconds." << std::endl;

    // compare them
    if (opt_duration.count() < dp_duration.count()) {
        std::cout << "The optimal algorithm won! "
                  << "(over the input size of " << array_size << ")" 
                  << std::endl;
    }
    else if(opt_duration.count() > dp_duration.count()) {
        std::cout << "The conventional DP algorithm won! "
                  << "(over the input size of " << array_size << ")" 
                  << std::endl;
    }
    else {
        std::cout << "There is a tie. "
                  << "(over the input size of " << array_size << ")" 
                  << std::endl;
    }

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: find_lis_optimal
 * @purpose: Find the longest increasing subsequence of the input array
 *           using an optimal approach
 * @parameters: none
 * @return: none
 */
void FindLIS::find_lis_optimal()
{
    // start the timer
    auto start = high_resolution_clock::now();
    
    // initialize the memos
    opt_aux_value.resize(array_size, std::numeric_limits<int>::max());
    opt_aux_index.resize(array_size);
    opt_previous.resize(array_size);

    // populate the memos
    for (std::size_t i = 0; i < array_size; i++) { 
        opt_populate_memos(i);
    }

    // // output the memos for testing FT
    // print_array("opt_aux_value", opt_aux_value); // FT
    // print_array("opt_aux_index", opt_aux_index); // FT
    // print_array("opt_previous", opt_previous); // FT

    // Find the LIS from memos
    find_lis_optimal_helper();

    // Print the LIS
    print_array("opt_lis", opt_lis);

    // compute the runtime
    auto end = high_resolution_clock::now();
    opt_duration = duration_cast<microseconds>(end - start);

}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: find_lis_optimal_helper
 * @purpose: Find the LIS from memos and populate the opt_lis vector
 * @parameters: none
 * @return: none
 */
void FindLIS::find_lis_optimal_helper()
{
    // find the LIS ending index
    int lis_end_index = find_lis_end_index();

    // find all indices of LIS
    int curr_index = lis_end_index;
    while (curr_index >= 0) {
        opt_index_stack.push(curr_index);
        curr_index = opt_previous[curr_index];
    }

    // find the LIS and populate the opt_lis vector
    while (not opt_index_stack.empty()) {
        opt_lis.push_back(input_array[opt_index_stack.top()]);
        opt_index_stack.pop();
    }

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: find_lis_end_index
 * @purpose: Find the end index of the LIS from memos of the optimal method
 * @parameters: none
 * @return: The end index of the LIS 
 */
int FindLIS::find_lis_end_index()
{
    for (std::size_t i = 0; i < array_size; i++) {
        if (i < array_size -1 and 
            opt_aux_value[i + 1] == std::numeric_limits<int>::max()) {
            return opt_aux_index[i];
        }
    }

    return opt_aux_index[array_size - 1];
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: opt_populate_memos
 * @purpose: Populate the auxiliary arrays (memos) of the input array
 * @parameters: An integer index of the input array
 * @return: none
 */
void FindLIS::opt_populate_memos(int index)
{
    int aux_index = -1;
    int prev_index = -1;
    
    // Base cases
    if (index < 0) {
        aux_index = -1;
    }
    else if (index == 0) {
        aux_index = 0;
    }
    else {
        // Recursive cases
        // find the position to insert the current element into the auxiliary
        aux_index = binary_search_position(input_array[index], 
                              opt_aux_value, 0, opt_aux_value.size() - 1);
        if (aux_index > 0) {
            prev_index = opt_aux_index[aux_index - 1];
        }
    }

    // populate the memos 
    if (aux_index >= 0) {
        opt_aux_value[aux_index] = input_array[index];
        opt_aux_index[aux_index] = index;
        opt_previous[index] = prev_index;
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: binary_search_position
 * @purpose: Find the index to insert the given value into the given array
 *           using binary search method
 * @parameters: 1) An integer value to insert
 *              2) A reference to the vector to be inserted
 *              3) An integer of the lower bound for search
 *              4) An integer of the higher bound for search
 * @return: An integer index as the insert position of given value
 *          into the array
 */
int FindLIS::binary_search_position(int value, const std::vector<int> & array,
                                    int low, int high)
{
    if (low <= high) {
        int mid = (low + high) / 2;

        if (value <= array[mid] and mid == 0) {
            return mid;
        }
        else if (value <= array[mid] and value > array[mid - 1]) {
            return mid;
        }
        else if (value < array[mid]) {
            return binary_search_position(value, array, low, mid - 1);
        }
        else {
            return binary_search_position(value, array, mid + 1, high);
        }
    }
    
    return -1;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: find_lis_dp
 * @purpose: Find the longest increasing subsequence of the input array
 *           using conventional dynamic programming approach, and 
 *           compute its runtime
 * @parameters: none
 * @return: none
 */
void FindLIS::find_lis_dp()
{
    // start the timer
    auto start = high_resolution_clock::now();
    
    // resize the memo arrays
    dp_auxiliary.resize(array_size);
    dp_previous.resize(array_size);

    // populate the memos
    for (std::size_t i = 0; i < array_size; i++) {
        dp_populate_memos(i);
    }

    // // output the memos for testing FT
    // print_array("dp_auxiliary", dp_auxiliary);
    // print_array("dp_previous", dp_previous);

    // find the LIS
    find_lis_dp_helper();

    // output the LIS
    print_array("dp_lis", dp_lis);

    // compute the runtime
    auto end = high_resolution_clock::now();
    dp_duration = duration_cast<microseconds>(end - start);

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: find_lis_dp_helper
 * @purpose: Find the longest increasing subsequence from the populated
 *           auxiliary arrays
 * @parameters: none
 * @return: none
 */
void FindLIS::find_lis_dp_helper()
{
    int dp_lis_length = 0;
    int dp_lis_end_index = 0;
    // find the length of LIS
    for (std::size_t i = 0; i < array_size; i++) {
        if (dp_auxiliary[i] > dp_lis_length) {
            dp_lis_length = dp_auxiliary[i];
            dp_lis_end_index = i;
        }
    }
    // populate the index stack
    int curr_index = dp_lis_end_index;
    while (curr_index >= 0) {
        dp_index_stack.push(curr_index);
        curr_index = dp_previous[curr_index];
    }

    // find the LIS according to the index stack
    while (not dp_index_stack.empty()) {
        dp_lis.push_back(input_array[dp_index_stack.top()]);
        dp_index_stack.pop();
    }
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: dp_populate_memos
 * @purpose: Populate the memos of the input array 
 * @parameters: The index of an element in the input array.
 * @return: The integer length of the LIS that ends in the input index.
 */
void FindLIS::dp_populate_memos(int index)
{
    int max_length = 1;
    int prev_index = -1;

    // Base cases
    if (index < 0) {
        max_length = 0;
    }
    else if (index == 0) {
        max_length = 1;
    }
    else {
        // Recursive cases
        for (int i = 0; i < index; i++) {
            if (input_array[i] < input_array[index] 
                and dp_auxiliary[i] >= max_length) {
                max_length = dp_auxiliary[i] + 1;
                prev_index = i;
            }
        }
    }

    // populate the memos
    dp_auxiliary[index] = max_length;
    dp_previous[index] = prev_index;
    
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: take_usr_input
 * @purpose: Prompt the user to input the array via std::cin and
 *           store the array
 * @parameters: none
 * @return: none
 */
void FindLIS::take_usr_input()
{
    // prompt the user to input the size of the input array and check it
    int size;
    std::cout << "Please enter the size of the input array: ";
    std::cin >> size;
    while (size < 0) {
        std::cerr << "Err: The size of the input array must be non-negative."
                  << std::endl;
        std::cout << "Please enter the size again: ";
        std::cin >> size;
    }

    if (size == 0) return;

    std::cout << "Please input the " << size << " integers of your array"
              << "(separated by space or enter): "
              << std::endl;
    
    // populate the input_array
    int num;
    for (int i = 0; i < size; i++) {
        // input validation
        while(not (std::cin >> num)) {
            std::cerr << "Error: An interger must be entered." << std::endl;
            std::cin.clear();
            std::cin.ignore(1, '\n');
            std::cout << "Please enter the current integer again: ";
        }
        // populate the input_array
        input_array.push_back(num);
    }

    // store the size info
    array_size = input_array.size();

}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: take_file_input
 * @purpose: populate the input_array according to the input file
 * @parameters: a string of the file name
 * @return: none
 */
void FindLIS::take_file_input(std::string filename) 
{
    // open the file & error check
    std::ifstream infile;
    open_or_exit(infile, filename);

    // populate the input array from the file
    int num;
    std::string next;
    while (infile >> next) {
        if (got_int(next, &num)) {
            input_array.push_back(num);
        }
        else {
            std::cerr << "Error: A non-integer does not count." << std::endl;
        }
    }

    // close the file
    infile.close();

    // store the size info
    array_size = input_array.size();
}


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: got_in
 * @purpose: Determine if the given string can be interpreted as a string 
 *			 and assign the integer value to resultup variable if it can. 
 * @parameters: 1) A given string
 *              2) A pointer to an integer variable
 * @return: True if what's in the string can be interpreted as an integer,
 *          false otherwise.
 * Note: This function is copied from the got_int.cpp file in my comp15 
 *       project 1.
 */
bool FindLIS::got_int(std::string s, int *resultp)
{
        // Holds the first non-whitespace character after the integer
        char extra;

        return sscanf(s.c_str(), " %d %c", resultp, &extra) == 1;
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: open_or_exit
 * @purpose: Try to open the given input file, or abort an failure
 * @parameters: 1) A reference to an input file stream
 *              2) A string of the file name
 * @return: none
 */
void FindLIS::open_or_exit(std::ifstream &input_stream, std::string filename)
{
    input_stream.open(filename);
    if (not input_stream.is_open()) {
        abort(filename + " cannot be opened.");
    }
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: abort
 * @purpose: Print an error message and exit the program
 * @parameters: A string of the error message
 * @return: none
 */
void FindLIS::abort(std::string prompt)
{
    std::cerr << prompt << std::endl;
    exit(EXIT_FAILURE);
}

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * @function: print_array
 * @purpose: Output the given vector with size info
 * @parameters: 1) A string of the vector's name
 *              2) A reference to the given output vector
 * @return: none
 */
void FindLIS::print_array(std::string array_name, 
                           const std::vector<int> &output_array)
{
    // output the input array size
    std::cout << "The " << array_name << " array size is: " 
              << output_array.size() << std::endl;
    
    // output each integer element
    if (output_array.size() != 0) {
        std::cout << "The " << array_name << " array is: ";
        for (const int & i : output_array) {
            std::cout << i << " ";
        }
        std::cout << std::endl << std::endl;
    }
    
}